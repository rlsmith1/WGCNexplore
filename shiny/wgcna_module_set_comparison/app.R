##
## describe application here
##


# required libraries ------------------------------------------------------

require(shiny)
require(tidyverse)
require(janitor)
require(RColorBrewer)
require(ggalluvial)
require(purrr)
require(biomaRt)
require(tidytext)
require(spsComps)
require(shinycustomloader)
require(shinybusy)


# source functions --------------------------------------------------------

source("functions/module_set_hypergeometric_overlap.R")
source("functions/f_top_GO_modules.R")

# data --------------------------------------------------------------------


# setwd("/Users/rachelsmith/Library/CloudStorage/OneDrive-NationalInstitutesofHealth/WGCNA/wgcna_app/shiny/wgcna_module_set_comparison/")

# load in transcript, gene, and GO information (df_transcript_gene_go_term)
load("objects/transcript_gene_go_term.RDS")

## read in cell-type data (data/cell_types.csv)
df_cell_type <- read.csv("data/cell_type.csv") %>%
        as_tibble()


# set theme for plots -----------------------------------------------------

theme_set(theme_bw() +
                  theme(plot.title = element_text(size = 20),
                        axis.title = element_text(size = 18),
                        axis.text = element_text(size = 15),
                        strip.text = element_text(size = 18),
                        legend.title = element_text(size = 18),
                        legend.text = element_text(size = 15)))

# UI ----------------------------------------------------------------------


ui <- fluidPage(

        ##
        ## APPLICATION TITLE
        ##

        titlePanel(title = div("WGCNA module set comparison",
                               img(src = "dna.png", height = 75, width = 150))),

        ##
        ## SIDEBAR LAYOUT
        ##
        tabsetPanel(
                
                ## OVERVIEW TAB
                tabPanel("Overview & usage", fluid = TRUE,
                         
                         sidebarLayout(
                                 
                                 sidebarPanel(
                                         "Contact me!",
                                         socialButton(
                                                 href = "mailto:rls83@cam.ac.uk",
                                                 icon = icon("envelope")
                                         ),                
                                         socialButton(
                                                 href = "https://www.linkedin.com/in/rachel-smith-495168163/",
                                                 icon = icon("linkedin")
                                         ),                
                                         socialButton(
                                                 href = "https://github.com/rlsmith1",
                                                 icon = icon("github")
                                         ),                
                                         socialButton(
                                                 href = "https://twitter.com/_raylsmith",
                                                 icon = icon("twitter")
                                         ),  
                                         socialButton(
                                                 href = "https://scholar.google.com/citations?view_op=list_works&hl=en&user=At3QMGAAAAAJ",
                                                 icon = icon("google")
                                         ),                
                                         
                                         width = 3),
                                 
                                 mainPanel(
                                         
                                         p("Hello and welcome! This app was designed to facilitate user exploration and comparison of gene or transcript modules 
                                 generated by Weighted Gene Co-Expression Analysis (WGCNA) ",
                                           tagList(a("(Langfelder & Horvath, BMC Bioinformatics 2008).", 
                                                     href = "https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-559")),
                                           "Currently, it designed for human transcriptomic data.
                                           Note: the app does NOT run WGCNA for you; users are recommended to use the ",
                                           tagList(a("WGCNA R package", 
                                                     href = "https://cran.r-project.org/web/packages/WGCNA/index.html")),
                                           ", tutorials for which are provided here: ",
                                           tagList(a("WGCNA tutorials", 
                                                     href = "https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/")),
                                           style = "font-si20pt"
                                         ),
                                         
                                         p("In this application, users may upload a CSV file delineating gene/transcript-module assignemnts 
                                         as generated by WGCNA. Genes and transcripts should be indicated by ensembl ID. Data may be uploaded in wide format 
                                   (top) or long format (bottom)",
                                           style = "font-si20pt" 
                                         ),
                                         
                                         p(img(src = "example_wide.png", width = 898/2, height = 676/2)),
                                         
                                         p(img(src = "example_long.png", width = 480/2, height = 676/2)),
                                         
                                         p("(These are just nonsensical example data, not the result of any analysis).
                                 Note the ensembl ID column should be named either ensembl_gene_id or ensembl_transcript_id, depending on if the data are
                                 genes or transcripts, respectively. Module sets and modules may be named as the user desires.",
                                           style = "font-si20pt"
                                         ),
                                         
                                         p("This application compares module sets in terms of module number and size, hypergeometric overlap between each module of each
                                 set, and cell-type enrichment. GO Functional enrichment ",
                                           tagList("(using the ",
                                                   a("topGO R package", 
                                                     href = "https://bioconductor.org/packages/release/bioc/html/topGO.html")),
                                           ") is also performed on each module of interest, as well as genes that intersect
                                 between modules of choice. All plots and data generated may be downloaded. Please contact me with any comments, issues, 
                                 suggestions, or feedback. Hope you find this useful!",
                                           style = "font-si20pt"),
                                         p(HTML('<center><img src="network.png" width="555.3333" height="273.3333"></center>'))                                         
                                 )
                                 
                         )
                         
                ),
                
                ## TAB 1
                tabPanel("Module sets overview", fluid = TRUE,

                         ## sidebar
                         sidebarLayout(

                                 sidebarPanel(
                                         
                                         fileInput("file",
                                                   "Please upload CSV file",
                                                   accept = c(
                                                           "text/csv",
                                                           "text/comma-separated-values,text/plain",
                                                           ".csv")
                                         ),
                                         checkboxGroupInput(inputId = "gene_or_transcript", 
                                                            label = "Data type (please select 1)", 
                                                            choices = c("Genes", "Transcripts")),
                                         
                                         uiOutput("mod_set1"),
                                         uiOutput("mod_set2"),
                                         checkboxInput(inputId = "grey_mod",
                                                       label = "Show grey?",
                                                       value = TRUE),
                                         actionButton(inputId = "go1",
                                                      label = "GO"),
                                         width = 3

                                 ),

                                 mainPanel(

                                         tabsetPanel(
                                                 id = "tabetPanelID",
                                                 type = "tabs",

                                                 tabPanel("Module number & size",
                                                          plotOutput("module_sizes", height = 500, width = 900) %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "module_sizes_download", label = "Download plot")
                                                 ),
                                                 tabPanel("Module overlap",
                                                          plotOutput("main_alluvial", height = 600, width = 900)  %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "main_alluvial_download", label = "Download plot"),

                                                          plotOutput("overlap_matrix", height = 600, width = 900)  %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "overlap_matrix_download", label = "Download plot"),
                                                          downloadButton(outputId = "df_overlap_download", label = "Download data")

                                                 ),
                                                 tabPanel("Cell-type enrichment",
                                                          plotOutput("cell_type", height = 800, width = 900) %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "cell_type_download", label = "Download plot")
                                                 ),
                                                 p(HTML('<center><img src="network.png" width="555.3333" height="273.3333"></center>'))

                                         )

                                 )

                         )

                ),

                ## TAB 2
                tabPanel("Module zoom", fluid = TRUE,

                         ## sidebar 2
                         sidebarLayout(

                                 sidebarPanel(

                                         uiOutput("mod_set_zoom"),
                                         uiOutput("mod_zoom"),
                                         checkboxInput(inputId = "q50",
                                                       label = "overlap >= 50 genes",
                                                       value = FALSE),
                                         actionButton(inputId = "go2",
                                                      label = "GO"),
                                         width = 3

                                 ),

                                 mainPanel(

                                         tabsetPanel(
                                                 id = "tabetPanelID",
                                                 type = "tabs",

                                                 tabPanel("Zoomed module overlaps",
                                                          plotOutput("zoom_alluvial", height = 600, width = 900) %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "zoom_alluvial_download", label = "Download plot")

                                                 ),
                                                 tabPanel("Zoomed module functional enrichment",
                                                          plotOutput("zoom_module_go", height = 800, width = 900) %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "zoom_module_go_download", label = "Download plot"),

                                                 ),
                                                 tabPanel("Overlapping modules functional enrichment",
                                                          plotOutput("zoom_module_overlaps_go", height = 1100, width = 900) %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "zoom_module_overlaps_go_download", label = "Download plot"),
                                                          downloadButton(outputId = "df_mods_go_download", label = "Download data")

                                                 ),
                                                 tabPanel("Overlaps only functional enrichment",
                                                          plotOutput("intersects_go", height = 1100, width = 900) %>%
                                                                  withLoader(type = "image", loader = "dna-spinning.gif"),
                                                          downloadButton(outputId = "intersects_go_download", label = "Download plot"),
                                                          downloadButton(outputId = "df_overlaps_go_download", label = "Download data")

                                                 ),
                                                 p(HTML('<center><img src="network.png" width="555.3333" height="273.3333"></center>'))

                                         )

                                 )
                         )

                )

        )

)




# Server ------------------------------------------------------------------


server <- function(input, output) {

        ##
        ## UPDATE SIDEBAR 2 BASED ON SIDEBAR 1 (NUMBER OF MOD_SETS) INPUT
        ##

        ##
        ## SET UP REACTIVES
        ##

        # read in data
        df_data_reactive <- reactive({

                in_file <- input$file

                if (is.null(in_file))
                        return(NULL)

                df_data <- read.csv(in_file$datapath) %>% as_tibble()

                if (ncol(df_data) > 3) {
                        
                        df_data <- df_data %>% pivot_longer(2:ncol(.), names_to = "mod_set", values_to = "module")
                        
                } else {
                        
                        df_data <- df_data %>% dplyr::rename_at(c(2, 3), ~c("mod_set", "module"))
                        
                }
                
        })

        # generate potential outputs
        mod_choices <- reactive({

                df_data <-  df_data_reactive()

                if (is.null(df_data)) {

                        return(NULL)

                } else
                        return(df_data %>% pull(mod_set) %>% unique())


        })
        output$mod_set1 <- renderUI({

                selectInput(inputId = "mod_set1",
                            label = "Module set 1",
                            choices = mod_choices(),
                            selected = NULL)

        })
        output$mod_set2 <- renderUI({

                selectInput(inputId = "mod_set2",
                            label = "Module set 2",
                            choices = mod_choices(),
                            selected = NULL)

        })

        # select module sets
        mod_set1 <- reactive({input$mod_set1})
        mod_set2 <- reactive({input$mod_set2})

        # create df_modules using these sets
        df_modules_reactive <- reactive({

                df_data <- df_data_reactive()
                df_data %>%
                        filter(mod_set %in% c(mod_set1(), mod_set2())) %>%
                        mutate_if(is.numeric, ~factor(.x, levels = 0:max(.x)))

        })

        # add modules for zoom
        output$mod_set_zoom <- renderUI({

                mod_set1 <- mod_set1()
                mod_set2 <- mod_set2()
                selectInput(inputId = "mod_set_zoom",
                            label = "Module set",
                            choices = c(mod_set1, mod_set2),
                            selected = mod_set1,
                            multiple = FALSE)

        }) %>% bindEvent(input$go1)
        output$mod_zoom <- renderUI({

                df_modules <- df_modules_reactive()

                selectInput(inputId = "mod_zoom",
                            label = "Module to zoom in on",
                            choices = levels(df_modules$module))


        }) %>% bindEvent(input$go1)

        # find maximum number of modules in either set
        n_mods <- reactive({

                df_modules <- df_modules_reactive()

                df_modules %>%
                        pull(module) %>%
                        as.character %>%
                        as.numeric %>%
                        max

        })

        # create color df for alluvial plots based on number of modules
        df_colors_reactive <- reactive({

                df_modules <- df_modules_reactive()

                qual_col_pals <- brewer.pal.info %>%
                        rownames_to_column("palette") %>%
                        filter(category == "qual", !grepl("Pastel", palette))

                col_vector <- c("#636363", unlist(mapply(brewer.pal,
                                                         (qual_col_pals$maxcolors - 1),
                                                         qual_col_pals$palette)))

                tibble(module = levels(df_modules$module),
                       color = col_vector[1:length(levels(df_modules$module))]) %>%
                        mutate(module = factor(module, levels = 0:max(as.numeric(module))))

        })

        # pull gene universe (all genes in all module sets)
        gene_universe_reactive <- reactive({

                df_modules <- df_modules_reactive()
                df_modules %>% pull(ensembl_gene_id) %>% unique

        })


        ##
        ## CHECK IF MODULE SET HAS BEEN RUN FOR HYPERGEOMETRIC OVERLAP, CELL-TYPE ENRICHMENT, AND FUNCTIONAL ENRICHMENT
        ##

        data <- reactiveValues()

        data$df_overlap <- tibble(mod_set1 = as.character(),
                                  mod_set2 = as.character(),
                                  mod1 = factor(),
                                  mod2 = factor(),
                                  overlap = as.numeric(),
                                  q = as.numeric(),
                                  m = as.numeric(),
                                  n = as.numeric(),
                                  k = as.numeric(),
                                  p_val = as.numeric(),
                                  p_adj = as.numeric())

        data$df_mods_go <- tibble(mod_set = as.character(),
                                  module = as.numeric(),
                                  go_id = as.character(),
                                  term = as.character(),
                                  annotated = as.numeric(),
                                  significant = as.numeric(),
                                  expected = as.numeric(),
                                  weight_fisher = as.numeric(),
                                  p_adj = as.numeric())

        data$df_overlaps_go <- tibble(mod_set1 = as.character(),
                                      mod_set2 = as.character(),
                                      mod1 = as.numeric(),
                                      mod2 = as.numeric(),
                                      go_id = as.character(),
                                      term = as.character(),
                                      annotated = as.numeric(),
                                      significant = as.numeric(),
                                      expected = as.numeric(),
                                      weight_fisher = as.numeric(),
                                      p_adj = as.numeric())

        # If module overlap has not been calculated, run hypergeometric tests here
        observeEvent(input$go1, {

                df_modules <- df_modules_reactive()

                modSet1 <- mod_set1()
                modSet2 <- mod_set2()

                modules1 <- df_modules %>%
                        filter(mod_set == modSet1) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique

                modules2 <- df_modules %>%
                        filter(mod_set == modSet2) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique

                if (
                        (nrow(data$df_overlap) == 0) |
                        (nrow(filter(data$df_overlap, mod_set1 == modSet1, mod_set2 == modSet2)) == 0)
                ) {

                        withProgress(message = paste0("calculating overlap for ", modSet1), value = 0, {

                                for (i in modules1) {

                                        # increment progress bar
                                        incProgress(1/length(modules1), detail = paste("Module ", i, " of ", length(modules1)))

                                        #print(paste0("module ", i, " of ", max(as.numeric(modules1)) - 1))

                                        # calculate
                                        df_tmp <- modules2 %>% map_dfr(~f_module_overlap(df = df_modules,
                                                                                         mod_set1 = modSet1,
                                                                                         mod_set2 = modSet2,
                                                                                         mod_no1 = i,
                                                                                         mod_no2 = .x)) %>%
                                                mutate(p_adj = p.adjust(p_val, method = "BH"))

                                        data$df_overlap <- bind_rows(data$df_overlap, df_tmp)

                                }

                        })

                        withProgress(message = paste0("calculating overlap for ", modSet2), value = 0, {

                                for (i in modules2) {

                                        # increment progress bar
                                        incProgress(1/length(modules2), detail = paste("Module ", i, " of ", length(modules2)))

                                        # print(paste0("module ", i, " of ", max(as.numeric(modules2)) - 1))

                                        df_tmp <- modules1 %>% map_dfr(~f_module_overlap(df = df_modules,
                                                                                         mod_set1 = modSet2,
                                                                                         mod_set2 = modSet1,
                                                                                         mod_no1 = i,
                                                                                         mod_no2 = .x)) %>%
                                                mutate(p_adj = p.adjust(p_val, method = "BH"))

                                        data$df_overlap <- bind_rows(data$df_overlap, df_tmp)

                                }

                        })


                }

        })

        # If functional enrichment on selected module and its overlaps hasn't been run, run topGO here
        observeEvent(input$go2, {
                
                # add loading message
                show_modal_gif(
                        # src = "https://jeroen.github.io/images/banana.gif",
                        src = "dna-spinning.gif",
                        text = "Please be patient, functional enrichment can take several minutes to run :)"
                )

                # create df_gene_go
                if (input$gene_or_transcript == "Genes") {
                        
                        df_gene_go <- df_transcript_gene_go_term %>% dplyr::select(-ensembl_transcript_id)
                        
                } else if (input$gene_or_transcript == "Transcripts") {
                        
                        df_gene_go <- df_transcript_gene_go_term %>% 
                                dplyr::select(-ensembl_gene_id)
                        
                }

                # unstack gene IDs and GO terms
                l_gene_2_GO <- df_gene_go %>%
                        dplyr::select(ensembl_gene_id, go_id) %>%
                        unstack()

                # bring in reactives & inputs
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                df_modules <- df_modules_reactive()
                gene_universe <- gene_universe_reactive()
                mod_zoom <- input$mod_zoom

                # bring in data
                df_overlap <- data$df_overlap

                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)

                overlap_mods <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)

                # run topGO on zoomed module

                withProgress(message = paste0(mod_set_zoom, " module ", mod_zoom), value = 0, {



                        if ((nrow(filter(data$df_mods_go, mod_set == mod_set_zoom, module == mod_zoom)) == 0)) {

                                doParallel::registerDoParallel()

                                module <- df_modules %>%
                                        filter(mod_set == mod_set_zoom & module == mod_zoom) %>%
                                        pull(ensembl_gene_id) %>%
                                        unique()

                                df_tmp <- f_top_GO_modules(gene_module = module,
                                                           gene_universe = gene_universe,
                                                           df_gene_go = df_gene_go,
                                                           l_gene_2_GO = l_gene_2_GO,
                                                           go_ontology = "BP") %>%
                                        mutate(module = mod_zoom, .before = 1) %>%
                                        clean_names() %>%
                                        dplyr::select(-term) %>%
                                        left_join(df_gene_go %>% dplyr::select(go_id, term),
                                                  by = "go_id") %>%
                                        dplyr::select(module, go_id, term, everything()) %>%
                                        distinct() %>%
                                        mutate(mod_set = mod_set_zoom, .before = 1) %>%
                                        mutate(module = as.numeric(module))

                                data$df_mods_go <- bind_rows(data$df_mods_go, df_tmp)

                        }

                })

                withProgress(message = "Module overlaps enrichment", value = 0, {

                        for (m in overlap_mods) {

                                # increment progress bar
                                incProgress(1/length(overlap_mods), detail = paste0(mod_set_other, " module ", m))

                                # run topGO on overlapping modules
                                if ((nrow(filter(data$df_mods_go, mod_set == mod_set_other, module == m)) == 0)) {

                                        doParallel::registerDoParallel()

                                        module <- df_modules %>%
                                                filter(mod_set == mod_set_other & module == m) %>%
                                                pull(ensembl_gene_id) %>%
                                                unique()

                                        df_tmp <- f_top_GO_modules(gene_module = module,
                                                                   gene_universe = gene_universe,
                                                                   df_gene_go = df_gene_go,
                                                                   l_gene_2_GO = l_gene_2_GO,
                                                                   go_ontology = "BP") %>%
                                                mutate(module = m, .before = 1) %>%
                                                clean_names() %>%
                                                dplyr::select(-term) %>%
                                                left_join(df_gene_go %>% dplyr::select(go_id, term),
                                                          by = "go_id") %>%
                                                dplyr::select(module, go_id, term, everything()) %>%
                                                distinct() %>%
                                                mutate(mod_set = mod_set_other, .before = 1) %>%
                                                mutate(module = as.numeric(module))

                                        data$df_mods_go <- bind_rows(data$df_mods_go, df_tmp)

                                }

                                # run topGO on gene intersects
                                if ((nrow(filter(data$df_overlaps_go,
                                                 mod_set1 == mod_set_zoom, mod1 == mod_zoom,
                                                 mod_set2 == mod_set_other, mod2 == m)) == 0)) {

                                        # increment progress bar
                                        incProgress(1/length(overlap_mods), detail = paste0(mod_set_zoom, " module ", mod_zoom,
                                                                                            " and ", mod_set_other, " module ", m, " intersect"))

                                        doParallel::registerDoParallel()

                                        module1 <- df_modules %>%
                                                filter(mod_set == mod_set_zoom & module == mod_zoom) %>%
                                                pull(ensembl_gene_id) %>%
                                                unique()

                                        module2 <- df_modules %>%
                                                filter(mod_set == mod_set_other & module == m) %>%
                                                pull(ensembl_gene_id) %>%
                                                unique()

                                        module_intersect <- intersect(module1, module2)

                                        df_tmp <- f_top_GO_modules(gene_module = module_intersect,
                                                                   gene_universe = gene_universe,
                                                                   df_gene_go = df_gene_go,
                                                                   l_gene_2_GO = l_gene_2_GO,
                                                                   go_ontology = "BP") %>%
                                                clean_names() %>%
                                                mutate(mod_set1 = mod_set_zoom,
                                                       mod_set2 = mod_set_other,
                                                       mod1 = mod_zoom,
                                                       mod2 = m) %>%
                                                dplyr::select(-term) %>%
                                                left_join(df_gene_go %>% dplyr::select(go_id, term),
                                                          by = "go_id") %>%
                                                # dplyr::select(module, go_id, term, everything()) %>%
                                                distinct() %>%
                                                mutate(mod1 = as.numeric(mod1),
                                                       mod2 = as.numeric(mod2))

                                        data$df_overlaps_go <- bind_rows(data$df_overlaps_go, df_tmp)

                                }

                        }


                })
                
                # remove loading message
                remove_modal_gif()

        })

        ##
        ## TAB 1 PLOTS
        ##

        # number & size of modules
        module_sizes_plot <- reactive({

                df_modules <- df_modules_reactive()
                n_mods <- n_mods()
                labels <- 0:n_mods %>% ifelse(. %% 5 == 0, ., "")

                df_modules %>%
                        group_by(mod_set) %>%
                        dplyr::count(module) %>%

                        ggplot(aes(x = module, y = n)) +
                        geom_point(aes(color = mod_set, size = n)) +
                        labs(y = "n_genes") +
                        scale_x_discrete(labels = labels,
                                         breaks = seq(from = 0, to = n_mods, by = 1)) +
                        facet_wrap(~mod_set, scales = "free_x") +
                        guides(color = "none") +
                        ggtitle("Number of genes in each module per set")

        })
        output$module_sizes <- renderPlot({

                module_sizes_plot()

        }, height = 500, width = 900) %>% bindEvent(input$go1)
        output$module_sizes_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_module_sizes_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 10, width = 15)
                        print(module_sizes_plot())
                        dev.off()
                })


        # main alluvial plot
        main_alluvial_plot <- reactive({

                df_modules <- df_modules_reactive()
                df_colors <- df_colors_reactive()

                df_alluvial <- df_modules %>%
                        dplyr::select(ensembl_gene_id, mod_set, module) %>%
                        left_join(df_colors, by = "module")

                # remove gray module?
                if (input$grey_mod == FALSE) {

                        df_alluvial <- df_alluvial %>% filter(module != 0)

                } else if (input$grey_mod == TRUE) {

                        df_alluvial <- df_alluvial

                }

                # plot
                df_alluvial %>%

                        ggplot(aes(x = mod_set, stratum = module, alluvium = ensembl_gene_id)) +
                        stat_stratum() +
                        geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
                        stat_flow(aes(fill = I(color))) +
                        labs(x = "module set") +
                        ggtitle("Alluvial plot")

        })
        output$main_alluvial <- renderPlot({

                main_alluvial_plot()

        }, height = 600, width = 900) %>% bindEvent(input$go1)
        output$main_alluvial_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_main_alluvial_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 10, width = 15)
                        print(main_alluvial_plot())
                        dev.off()
                })

        # overlap matrix plot
        overlap_matrix_plot <- reactive({

                df_overlap <- data$df_overlap
                df_modules <- df_modules_reactive()
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()

                modules1 <- df_modules %>%
                        filter(mod_set == modSet1) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique

                modules2 <- df_modules %>%
                        filter(mod_set == modSet2) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique

                # format for plotting
                df_overlap_plot <-
                        df_overlap %>%
                        filter(mod_set1 == modSet1 & mod_set2 == modSet2) %>%
                        mutate(is_big = ifelse(q >= 50, 1 , 0) %>% factor()) %>%
                        mutate(p_adj = ifelse(p_adj > 0.05, NA, p_adj)) %>% # set p_adj = 1 to NA
                        mutate(p_adj = ifelse(p_adj == 0, 1e-300, p_adj)) %>%
                        mutate(mod_set1 = factor(mod_set1, levels = unique(.$mod_set1))) %>%
                        mutate(mod1 = factor(mod1, levels = levels(df_overlap$mod2)),
                               mod2 = factor(mod2, levels = levels(df_overlap$mod2))) %>%
                        dplyr::select(-c(q, m, n, k))

                # plot
                df_overlap_plot %>%

                        ggplot(aes(x = mod1, y = mod2)) +
                        geom_tile(aes(fill = -log10(p_adj))) +
                        geom_text(data = df_overlap_plot %>% filter(p_adj < 0.05),
                                  mapping = aes(label = overlap),
                                  size = 6) +

                        scale_fill_gradientn(colors = brewer.pal(5, "Reds"), na.value = "white") +
                        scale_x_discrete(limits = modules1) +
                        scale_y_discrete(limits = modules2) +
                        labs(x = modSet1, y = modSet2) +
                        ggtitle("Hypergeometric overlaps")

        })
        output$overlap_matrix <- renderPlot({

                overlap_matrix_plot()

        }, height = 600, width = 900) %>% bindEvent(input$go1)
        output$overlap_matrix_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_overlap_matrix_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 10, width = 15)
                        print(overlap_matrix_plot())
                        dev.off()
                })
        output$df_overlap_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_hypergeometrix_overlap.csv")},

                content = function(file) {

                        write.csv(data$df_overlap, file, row.names = FALSE)

                }

        )

        # cell-type enrichment plot
        cell_type_plot <- reactive({

                df_modules <- df_modules_reactive()
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()

                df_modules %>%
                        filter(mod_set %in% c(modSet1, modSet2)) %>%

                        dplyr::select(mod_set, ensembl_gene_id, module) %>%
                        left_join(df_cell_type, by = "ensembl_gene_id") %>%
                        group_by(mod_set, module) %>%
                        dplyr::count(type) %>%
                        mutate(z_score = (n - mean(n, na.rm = TRUE))/sd(n, na.rm = TRUE)) %>%
                        na.omit() %>%

                        # filter(!grepl("synapses", type)) %>%

                        ggplot(aes(x = type, y = module,
                                   fill = z_score)) +
                        geom_tile(aes(width = 0.95, height = 0.95)) +
                        scale_fill_gradientn(colors = rev(brewer.pal(9, "RdBu")), limits = c(-3, 3)) +
                        facet_wrap(~mod_set, scales = "free", nrow = 2) +
                        labs(x = "Lake cell type") +
                        coord_flip()

        })
        output$cell_type <- renderPlot({

                cell_type_plot()

        }, height = 800, width = 900) %>% bindEvent(input$go1)
        output$cell_type_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_cell_type_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 15, width = 15)
                        print(cell_type_plot())
                        dev.off()
                })

        ##
        ## TAB 2 PLOTS
        ##

        # alluvial zoom plot
        zoom_alluvial_plot <- reactive({

                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom

                df_colors <- df_colors_reactive()
                df_modules <- df_modules_reactive()
                df_overlap <- data$df_overlap

                # q > 50?
                if (input$q50 == FALSE) {

                        df_overlap <- df_overlap

                } else if (input$q50 == TRUE) {

                        df_overlap <- df_overlap %>% filter(q >= 50)

                }

                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)

                m <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)

                df_alluvial_zoom <- df_modules %>%
                        filter((mod_set == mod_set_zoom & module == mod_zoom) |
                                       (mod_set == mod_set_other & module %in% m))

                # plot
                df_alluvial_zoom %>%
                        left_join(df_colors) %>%

                        ggplot(aes(x = mod_set, stratum = module, alluvium = ensembl_gene_id)) +
                        stat_stratum() +
                        geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
                        stat_flow(aes(fill = I(color))) +
                        labs(x = "module set") +
                        ggtitle("Zoomed module overlaps")

        })
        output$zoom_alluvial <- renderPlot({

                zoom_alluvial_plot()

        }, height = 600, width = 900) %>% bindEvent(input$go2)
        output$zoom_alluvial_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_zoom_alluvial_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 10, width = 15)
                        print(cell_type_plot())
                        dev.off()
                })

        # zoomed module enrichment
        zoom_module_go_plot <- reactive({

                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom
                df_mods_go <- data$df_mods_go

                # select module set
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)

                # plot
                df_mods_go %>%
                        filter(mod_set == mod_set_zoom & module == mod_zoom) %>%
                        arrange(p_adj) %>%
                        dplyr::slice(1:10) %>%

                        ggplot(aes(x = -log10(p_adj), y = reorder(str_wrap(term, width = 35), -p_adj))) +
                        geom_point(aes(size = significant/annotated, color = -log10(p_adj))) +
                        labs(y = "") +

                        geom_vline(aes(xintercept = -log10(0.05)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.01)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.001)), lty = 2, color = "black") +
                        scale_color_gradientn(colors = brewer.pal(9, "Reds")[3:9]) +

                        ggtitle(paste0(mod_set_zoom, " module ", mod_zoom, " enrichment"))

        })
        output$zoom_module_go <- renderPlot({

                zoom_module_go_plot()

        }, height = 1100, width = 900) %>% bindEvent(input$go2)
        output$zoom_module_go_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_zoom_module_go_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 20, width = 15)
                        print(zoom_module_go_plot())
                        dev.off()
                })

        # zoomed module overlapping modules (full) enrichment
        zoom_module_overlaps_go_plot <- reactive({

                # bring in reactives & inputs
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom

                # bring in data
                df_overlap <- data$df_overlap
                df_mods_go <- data$df_mods_go

                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)

                overlap_mods <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)

                # plot
                df_mods_go %>%

                        filter(mod_set == mod_set_other & module %in% overlap_mods) %>%
                        group_by(module) %>%
                        arrange(module, p_adj) %>%
                        dplyr::top_n(n = 10) %>%
                        group_modify(~head(.x, 10)) %>%

                        ggplot(aes(x = -log10(p_adj), y = reorder_within(str_wrap(term, width = 35), -p_adj, module))) +
                        geom_point(aes(size = significant/annotated, color = -log10(p_adj))) +
                        labs(y = "") +
                        facet_wrap(~module, scales = "free", ncol = 2) +
                        scale_y_discrete(labels = function(x) gsub("*_.", "", x)) +

                        geom_vline(aes(xintercept = -log10(0.05)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.01)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.001)), lty = 2, color = "black") +
                        scale_color_gradientn(colors = brewer.pal(9, "Reds")[3:9]) +

                        ggtitle(paste0(mod_set_other, " module ", paste(overlap_mods, sep = ", "), " enrichment"))

        })
        output$zoom_module_overlaps_go <- renderPlot({

                zoom_module_overlaps_go_plot()

        }, height = 1100, width = 900) %>% bindEvent(input$go2)
        output$zoom_module_overlaps_go_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_zoom_module_overlaps_go_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 20, width = 15)
                        print(zoom_module_overlaps_go_plot())
                        dev.off()
                })
        output$df_mods_go_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_module_GO_results.csv")},

                content = function(file) {

                        write.csv(data$df_mods_go, file, row.names = FALSE)

                }

        )

        # intersecting gene sets enrichment
        intersects_go_plot <- reactive({

                # bring in reactives & inputs
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom

                # bring in data
                df_overlap <- data$df_overlap
                df_mods_go <- data$df_mods_go
                df_overlaps_go <- data$df_overlaps_go

                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)

                overlap_mods <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)

                # plot
                df_overlaps_go %>%

                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom,
                               mod_set2 == mod_set_other & mod2 %in% overlap_mods) %>%
                        group_by(mod2) %>%
                        arrange(mod2, p_adj) %>%
                        dplyr::top_n(n = 10) %>%
                        group_modify(~head(.x, 10)) %>%

                        ggplot(aes(x = -log10(p_adj), y = reorder_within(str_wrap(term, width = 35), -p_adj, mod2))) +
                        geom_point(aes(size = significant/annotated, color = -log10(p_adj))) +
                        labs(y = "") +
                        facet_wrap(~mod2 , scales = "free", ncol = 2) +
                        scale_y_discrete(labels = function(x) gsub("*_.", "", x)) +

                        geom_vline(aes(xintercept = -log10(0.05)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.01)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.001)), lty = 2, color = "black") +
                        scale_color_gradientn(colors = brewer.pal(9, "Reds")[3:9]) +

                        ggtitle("Intersecting gene enrichment")

        })
        output$intersects_go <- renderPlot({

                intersects_go_plot()

        }, height = 800, width = 900) %>% bindEvent(input$go2)
        output$intersects_go_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_intersects_go_plot", ".pdf")},

                content = function(file) {

                        pdf(file, height = 20, width = 15)
                        print(intersects_go_plot())
                        dev.off()
                })
        output$df_overlaps_go_download <- downloadHandler(

                filename = function() {paste0(Sys.Date(), "_module_overlap_GO_results.csv")},

                content = function(file) {

                        write.csv(data$df_overlaps_go, file, row.names = FALSE)

                }

        )


}


# Run app -----------------------------------------------------------------


shinyApp(ui = ui, server = server)

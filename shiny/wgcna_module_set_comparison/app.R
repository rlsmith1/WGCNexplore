

# required libraries ------------------------------------------------------

library(spsComps)
library(shinycustomloader)
library(shinybusy)
library(shinydashboard)
library(shinydashboardPlus)

library(tidyverse)
library(janitor)
library(RColorBrewer)
library(ggalluvial)
library(purrr)
library(tidytext)
library(topGO)
library(GO.db)


# source functions --------------------------------------------------------

source("./functions/module_set_hypergeometric_overlap.R")
source("./functions/f_top_GO_modules.R")

# data --------------------------------------------------------------------


# load in transcript, gene, and GO information (df_transcript_gene_go_term)
load("./objects/transcript_gene_go_term.RDS")

## read in cell-type data (data/cell_types.csv)
df_cell_type <- read.csv("./data/cell_type.csv") %>%
        as_tibble()


# set theme for plots -----------------------------------------------------

theme_set(theme_bw() +
                  theme(plot.title = element_text(size = 20),
                        axis.title = element_text(size = 18),
                        axis.text = element_text(size = 15),
                        strip.text = element_text(size = 18),
                        legend.title = element_text(size = 18),
                        legend.text = element_text(size = 15)))



# welcome page text -------------------------------------------------------

text <- h4(
        
        p("Hello and welcome! This app was designed to facilitate user exploration and comparison of 
          gene or transcript modules generated by Weighted Gene Co-Expression Analysis (WGCNA) ",
          tagList(a("(Langfelder & Horvath, BMC Bioinformatics 2008).",
                    href = "https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-559")),
          "Currently, it designed for human transcriptomic data.
                                                   Note: the app does NOT run WGCNA for you; users are recommended to use the ",
          tagList(a("WGCNA R package",
                    href = "https://cran.r-project.org/web/packages/WGCNA/index.html")),
          ", tutorials for which are provided here: ",
          tagList(a("WGCNA tutorials",
                    href = "https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/"))
        ),
        
        p(strong("Overview:")),
        
        p("Weighted Gene Co-expression Network Analysis (WGCNA) 
        is a widely used bioinformatics method that defines gene clusters (modules) based on expression levels, 
          allowing the user to study the relationships between these modules and compare network topologies across expression datasets. 
          This approach overcomes challenges of gene-based studies, but it is difficult to compare WGCNA results within & across datasets, 
          as generated modules are highly dependent on user parameter inputs. As such, validation of modules based on module sizes (including grey module), 
          number of modules in set, and biological data including cell-type and functional enrichment is an essential step in WGCNA analyses.
          We developed this application to facilitate and encourage user exploration of modules generated by their own 
          WGCNA analyses of human transcriptomic data."),
        
        p(strong("Usage instructions:")),
        
        p("In this application, users may upload a CSV file delineating gene/transcript-module assignemnts as generated by WGCNA. 
        Genes and transcripts should be indicated by ensembl ID. Data may be uploaded in wide format (left) or long format (right):",
        ),
        
        p(img(src = "example_wide.png", width = 898/2, height = 676/2), 
          strong("--OR--"),
          img(src = "example_long.png", width = 480/2, height = 676/2)),
        
        p("(These are just example data, not the result of any analysis). 
        Note the ensembl ID column should be named either ensembl_gene_id or ensembl_transcript_id, 
          depending on if the data are genes or transcripts, respectively. Module sets and modules may be named as the user desires."
        ),
        
        p("This application compares module sets in terms of module number and size as well as hypergeometric overlap between each module of each set. 
          Z-scored cell-type enrichment for each module is calculated using the ",
          tagList(a("Lake et al (2018)",
                    href = "https://www.nature.com/articles/nbt.4038")),
          "cell-type dataset. The user also has the option to provide their own cell-type data, in the following format:"
        ),
        p(img(src = "df_cell_type.png", width = 748/2, height = 138/2)),
        
        p("GO Functional enrichment ",
          tagList("(using the ",
                  a("topGO R package",
                    href = "https://bioconductor.org/packages/release/bioc/html/topGO.html")),
          ", version 2.48.0) is also performed on each module of interest, as well as genes that intersect between modules of choice."),
        
        p("Once plots have been generated and functional enrichment has been run for a given module/module set combo, 
        these plots & results are stored and do not need to be rerun (within a session). 
        All plots are downloadable as PDFs and all data tables (hypergeometric test and functional enrichment results) are downloadable as CSVs.
        Please contact me with any comments, issues, suggestions, or feedback. 
          Hope you find this useful!!"),  
        
        br(),
        p(em("App initially generated with: R version 4.2.0, 
        RStudio 2022.07.1+554 Release (7872775ebddc40635780ca1ed238934c3345c5de, 2022-07-22) for macOS,
          shiny version 1.7.2, shinydashboard version 0.7.2")),
        p(em("Last updated", Sys.Date())),
        br()
        
)



# footer ------------------------------------------------------------------


footer <- fluidRow(
        
        align = "center",
        
        box(title = tags$b("Contact me!"), width = 12, background = "blue",
            
            img(src = "NIMH_logo.png", width = 485/1.5, height = 127/1.5),
            img(src = "blank.png", width = 87, height = 75),
            
            socialButton(
                    href = "mailto:rls83@cam.ac.uk",
                    icon = icon("envelope")
            ),
            socialButton(
                    href = "https://www.linkedin.com/in/rachel-smith-495168163/",
                    icon = icon("linkedin")
            ),
            socialButton(
                    href = "https://github.com/rlsmith1",
                    icon = icon("github")
            ),
            socialButton(
                    href = "https://twitter.com/_raylsmith",
                    icon = icon("twitter")
            ),
            socialButton(
                    href = "https://scholar.google.com/citations?view_op=list_works&hl=en&user=At3QMGAAAAAJ",
                    icon = icon("google")
            ),
            
            img(src = "blank.png", width = 87, height = 75),
            img(src = "CAM_logo.jpeg", width = 485/1.5, height = 127/1.5)
            
        )
        
)

# app ---------------------------------------------------------------------

# tags$style(".fa-envelope {color:#FFFFFF}"),

##
## HEADER
##

header <- dashboardHeader(
        
        # title = paste0(strong("WGCNe"), icon("dna"), strong("plore"))
        title = strong("WGCNexplore", titleWidth = 600)
        
)

##
## SIDEBAR LAYOUT
##

sidebar <- dashboardSidebar(
        
        sidebarMenu(
                
                menuItem("Overview & Usage", tabName = "Tab1", icon = icon("info")),
                menuItem("Module overlap", tabName = "Tab2", icon = icon('circle-nodes')),
                menuItem("Module zoom & enrichment", tabName = "Tab3", icon = icon("dna")),
                menuItem("Source code", icon = icon("code"), href = "https://github.com/rlsmith1/wgcna_app")
        )
)

##
## UI BODY
##

body <- dashboardBody(
        
        tabItems(
                
                tabItem(tabName = "Tab1",
                        h2("WGCNA module set comparison"),
                        text,
                        footer
                        
                ),
                
                tabItem(tabName = "Tab2",
                        h2("Module set overlap"),
                        
                        fluidRow(
                                
                                box(
                                        title = "Data input & module selection", status = "primary", width = 3, 
                                        solidHeader = TRUE, collapsible = TRUE,
                                        
                                        fileInput(inputId = "file",
                                                  label = "Upload gene-module assignments as CSV file",
                                                  accept = c(
                                                          "text/csv",
                                                          "text/comma-separated-values,text/plain",
                                                          ".csv")
                                        ),
                                        
                                        fileInput(inputId = "cell_type_data",
                                                  label = "Upload cell-type CSV file (optional; Lake et al 2018 will be used if this field is left blank)", 
                                                  accept = c(
                                                          "text/csv",
                                                          "text/comma-separated-values,text/plain",
                                                          ".csv")
                                        ),
                                        
                                        checkboxGroupInput(inputId = "genes_or_transcripts",
                                                           label = "Data type (please select 1)",
                                                           choices = c("Genes", "Transcripts")),
                                        
                                        uiOutput("mod_set1"),
                                        uiOutput("mod_set2"),
                                        checkboxInput(inputId = "grey_mod",
                                                      label = "Show grey?",
                                                      value = TRUE),
                                        actionButton(inputId = "go1",
                                                     label = "GO",
                                                     icon = icon("arrows-rotate")
                                        )
                                ),
                                
                                tabBox(
                                        title = NULL,
                                        width = 9,
                                        side = "right",
                                        selected = "Module number & size",
                                        id = "tabset1", height = "900px",
                                        
                                        tabPanel("Cell-type enrichment", align = "center",
                                                 plotOutput("cell_type", height = 800, width = 1000) %>%
                                                         withLoader(type = "image", loader = "dna-spinning.gif"),
                                                 downloadButton(outputId = "cell_type_download", label = "Download plot")
                                        ),
                                        
                                        tabPanel("Module overlap matrix", align = "center",
                                                 plotOutput("overlap_matrix", height = 800, width = 1000),
                                                 downloadButton(outputId = "overlap_matrix_download", label = "Download plot"),
                                                 downloadButton(outputId = "df_overlap_download", label = "Download data")
                                                 
                                        ),
                                        
                                        tabPanel("Module overlap alluvial", align = "center",
                                                 plotOutput("main_alluvial", height = 800, width = 1000)  %>%
                                                         withLoader(type = "image", loader = "dna-spinning.gif"),
                                                 downloadButton(outputId = "main_alluvial_download", label = "Download plot"),
                                                 
                                        ),
                                        
                                        tabPanel("Module number & size", align = "center",
                                                 plotOutput("module_sizes", height = 650, width = 1000) %>%
                                                         withLoader(type = "image", loader = "dna-spinning.gif"),
                                                 downloadButton(outputId = "module_sizes_download", label = "Download plot")
                                        )
                                )
                        ),
                        footer
                        
                ),
                
                tabItem(tabName = "Tab3",
                        h2("Module zoom & functional enrichment"),
                        
                        fluidRow(
                                
                                box(
                                        title = "Select module of interest", status = "primary", width = 3, 
                                        solidHeader = TRUE, collapsible = TRUE, 
                                        
                                        uiOutput("mod_set_zoom"),
                                        uiOutput("mod_zoom"),
                                        checkboxInput(inputId = "q50",
                                                      label = "overlap >= 50 genes",
                                                      value = FALSE),
                                        actionButton(inputId = "go2",
                                                     label = "GO", icon = icon("arrows-rotate"))
                                ),
                                
                                box(
                                        title = "Zoomed module overlaps", width = 9, collapsible = TRUE, 
                                        
                                        plotOutput("zoom_alluvial", height = 600, width = 1000) %>%
                                                withLoader(type = "image", loader = "dna-spinning.gif"),
                                        downloadButton(outputId = "zoom_alluvial_download", label = "Download plot")
                                ),
                                
                                tabBox(
                                        title = "Functional enrichment results",
                                        width = 12,
                                        side = "right",
                                        selected = "Zoomed module functional enrichment",
                                        id = "tabset2", height = "900px",
                                        
                                        tabPanel("Overlaps only functional enrichment", align = "center",
                                                 plotOutput("intersects_go", height = 800, width = 1000) %>%
                                                         withLoader(type = "image", loader = "dna-spinning.gif"),
                                                 downloadButton(outputId = "intersects_go_download", label = "Download plot"),
                                                 downloadButton(outputId = "df_overlaps_go_download", label = "Download data")
                                                 
                                        ),
                                        tabPanel("Overlapping modules functional enrichment", align = "center",
                                                 plotOutput("zoom_module_overlaps_go", height = 800, width = 1000) %>%
                                                         withLoader(type = "image", loader = "dna-spinning.gif"),
                                                 downloadButton(outputId = "zoom_module_overlaps_go_download", label = "Download plot"),
                                                 downloadButton(outputId = "df_mods_go_download", label = "Download data")
                                                 
                                        ),
                                        tabPanel("Zoomed module functional enrichment", align = "center",
                                                 plotOutput("zoom_module_go", height = 800, width = 1000) %>%
                                                         withLoader(type = "image", loader = "dna-spinning.gif"),
                                                 downloadButton(outputId = "zoom_module_go_download", label = "Download plot")
                                                 
                                        )
                                )
                        ),
                        footer
                )
        ) 
)

##
## UI
##

ui <- dashboardPage(header, sidebar, body)

##
## SERVER
##

server <- function(input, output, session) {
        
        ##
        ## UPDATE SIDEBAR 2 BASED ON SIDEBAR 1 (NUMBER OF MOD_SETS) INPUT
        ##
        
        ##
        ## SET UP REACTIVES
        ##
        
        # read in data
        df_data_reactive <- reactive({
                
                in_file <- input$file
                
                if (is.null(in_file))
                        return(NULL)
                
                df_data <- read.csv(in_file$datapath) %>% as_tibble()
                
                if (ncol(df_data) > 3) {
                        
                        df_data <- df_data %>% pivot_longer(2:ncol(.), names_to = "mod_set", values_to = "module")
                        
                } else {
                        
                        df_data <- df_data %>% dplyr::rename_at(c(2, 3), ~c("mod_set", "module"))
                        
                }
                
        })
        
        # generate potential outputs
        mod_choices <- reactive({
                
                df_data <-  df_data_reactive()
                
                if (is.null(df_data)) {
                        
                        return(NULL)
                        
                } else
                        return(df_data %>% pull(mod_set) %>% unique())
                
                
        })
        output$mod_set1 <- renderUI({
                
                selectInput(inputId = "mod_set1",
                            label = "Module set 1",
                            choices = mod_choices(),
                            selected = NULL)
                
        })
        output$mod_set2 <- renderUI({
                
                selectInput(inputId = "mod_set2",
                            label = "Module set 2",
                            choices = mod_choices(),
                            selected = NULL)
                
        })
        
        # select module sets
        mod_set1 <- reactive({input$mod_set1})
        mod_set2 <- reactive({input$mod_set2})
        
        # create df_modules using these sets
        df_modules_reactive <- reactive({
                
                df_data <- df_data_reactive()
                df_data %>%
                        filter(mod_set %in% c(mod_set1(), mod_set2())) %>%
                        mutate_if(is.numeric, ~factor(.x, levels = 0:max(.x)))
                
        })
        
        # add modules for zoom
        output$mod_set_zoom <- renderUI({
                
                mod_set1 <- mod_set1()
                mod_set2 <- mod_set2()
                selectInput(inputId = "mod_set_zoom",
                            label = "Module set",
                            choices = c(mod_set1, mod_set2),
                            selected = mod_set1,
                            multiple = FALSE)
                
        }) %>% bindEvent(input$go1)
        output$mod_zoom <- renderUI({
                
                df_modules <- df_modules_reactive()
                
                selectInput(inputId = "mod_zoom",
                            label = "Module to zoom in on",
                            choices = levels(df_modules$module))
                
                
        }) %>% bindEvent(input$go1)
        
        # find maximum number of modules in either set
        n_mods <- reactive({
                
                df_modules <- df_modules_reactive()
                
                df_modules %>%
                        pull(module) %>%
                        as.character %>%
                        as.numeric %>%
                        max
                
        })
        
        # get cell-type data
        df_cell_type_reactive <- reactive({
                
                cell_type_data <- input$cell_type_data
                
                if (is.null(cell_type_data)) {
                        
                        read.csv("./data/cell_type.csv") %>%
                                as_tibble()
                        
                }
                
                else (read.csv(cell_type_data$datapath) %>% as_tibble())
                
        })
        
        
        # create color df for alluvial plots based on number of modules
        df_colors_reactive <- reactive({
                
                df_modules <- df_modules_reactive()
                
                qual_col_pals <- brewer.pal.info %>%
                        rownames_to_column("palette") %>%
                        filter(category == "qual", !grepl("Pastel", palette))
                
                col_vector <- c("#636363", unlist(mapply(brewer.pal,
                                                         (qual_col_pals$maxcolors - 1),
                                                         qual_col_pals$palette)))
                
                tibble(module = levels(df_modules$module),
                       color = col_vector[1:length(levels(df_modules$module))]) %>%
                        mutate(module = factor(module, levels = 0:max(as.numeric(module))))
                
        })
        
        # pull gene universe (all genes in all module sets)
        gene_universe_reactive <- reactive({
                
                df_modules <- df_modules_reactive()
                df_modules %>% pull(ensembl_gene_id) %>% unique
                
        })
        
        
        ##
        ## CHECK IF MODULE SET HAS BEEN RUN FOR HYPERGEOMETRIC OVERLAP, CELL-TYPE ENRICHMENT, AND FUNCTIONAL ENRICHMENT
        ##
        
        data <- reactiveValues()
        
        data$df_overlap <- tibble(mod_set1 = as.character(),
                                  mod_set2 = as.character(),
                                  mod1 = factor(),
                                  mod2 = factor(),
                                  overlap = as.numeric(),
                                  q = as.numeric(),
                                  m = as.numeric(),
                                  n = as.numeric(),
                                  k = as.numeric(),
                                  p_val = as.numeric(),
                                  p_adj = as.numeric())
        
        data$df_mods_go <- tibble(mod_set = as.character(),
                                  module = as.numeric(),
                                  go_id = as.character(),
                                  term = as.character(),
                                  annotated = as.numeric(),
                                  significant = as.numeric(),
                                  expected = as.numeric(),
                                  weight_fisher = as.numeric(),
                                  p_adj = as.numeric())
        
        data$df_overlaps_go <- tibble(mod_set1 = as.character(),
                                      mod_set2 = as.character(),
                                      mod1 = as.numeric(),
                                      mod2 = as.numeric(),
                                      go_id = as.character(),
                                      term = as.character(),
                                      annotated = as.numeric(),
                                      significant = as.numeric(),
                                      expected = as.numeric(),
                                      weight_fisher = as.numeric(),
                                      p_adj = as.numeric())
        
        # If module overlap has not been calculated, run hypergeometric tests here
        observeEvent(input$go1, {
                
                df_modules <- df_modules_reactive()
                
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                
                modules1 <- df_modules %>%
                        filter(mod_set == modSet1) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique
                
                modules2 <- df_modules %>%
                        filter(mod_set == modSet2) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique
                
                if (
                        (nrow(data$df_overlap) == 0) |
                        (nrow(filter(data$df_overlap, mod_set1 == modSet1, mod_set2 == modSet2)) == 0)
                ) {
                        
                        withProgress(message = paste0("calculating overlap for ", modSet1), value = 0, {
                                
                                for (i in modules1) {
                                        
                                        # increment progress bar
                                        incProgress(1/length(modules1), detail = paste("Module ", i, " of ", length(modules1)))
                                        
                                        #print(paste0("module ", i, " of ", max(as.numeric(modules1)) - 1))
                                        
                                        # calculate
                                        df_tmp <- modules2 %>% map_dfr(~f_module_overlap(df = df_modules,
                                                                                         mod_set1 = modSet1,
                                                                                         mod_set2 = modSet2,
                                                                                         mod_no1 = i,
                                                                                         mod_no2 = .x)) %>%
                                                mutate(p_adj = p.adjust(p_val, method = "BH"))
                                        
                                        data$df_overlap <- bind_rows(data$df_overlap, df_tmp)
                                        
                                }
                                
                        })
                        
                        withProgress(message = paste0("calculating overlap for ", modSet2), value = 0, {
                                
                                for (i in modules2) {
                                        
                                        # increment progress bar
                                        incProgress(1/length(modules2), detail = paste("Module ", i, " of ", length(modules2)))
                                        
                                        # print(paste0("module ", i, " of ", max(as.numeric(modules2)) - 1))
                                        
                                        df_tmp <- modules1 %>% map_dfr(~f_module_overlap(df = df_modules,
                                                                                         mod_set1 = modSet2,
                                                                                         mod_set2 = modSet1,
                                                                                         mod_no1 = i,
                                                                                         mod_no2 = .x)) %>%
                                                mutate(p_adj = p.adjust(p_val, method = "BH"))
                                        
                                        data$df_overlap <- bind_rows(data$df_overlap, df_tmp)
                                        
                                }
                                
                        })
                        
                        
                }
                
        })
        
        # If functional enrichment on selected module and its overlaps hasn't been run, run topGO here
        observeEvent(input$go2, {
                
                # create df_gene_go
                if (input$genes_or_transcripts == "Genes") {
                        
                        df_gene_go <- df_transcript_gene_go_term %>% 
                                dplyr::select(-ensembl_transcript_id)
                        
                } else if (input$genes_or_transcripts == "Transcripts") {
                        
                        df_gene_go <- df_transcript_gene_go_term %>%
                                dplyr::select(-ensembl_gene_id)
                        
                }
                
                # unstack gene IDs and GO terms
                l_gene_2_GO <- df_gene_go %>%
                        dplyr::select(ensembl_gene_id, go_id) %>%
                        unstack()
                
                # bring in reactives & inputs
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                df_modules <- df_modules_reactive()
                gene_universe <- gene_universe_reactive()
                mod_zoom <- input$mod_zoom
                
                # bring in data
                df_overlap <- data$df_overlap
                
                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)
                
                overlap_mods <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)
                
                # add loading message
                show_modal_gif(
                        src = "dna-spinning.gif",
                        text = paste0("Estimated run time: ", 2*(1 + 2*length(overlap_mods)), "-", round(2.5*(1 + 2*length(overlap_mods))), " minutes")
                )
                
                # run topGO on zoomed module
                
                if ((nrow(filter(data$df_mods_go, mod_set == mod_set_zoom, module == mod_zoom)) == 0)) {
                        
                        doParallel::registerDoParallel()
                        
                        module <- df_modules %>%
                                filter(mod_set == mod_set_zoom & module == mod_zoom) %>%
                                pull(ensembl_gene_id) %>%
                                unique()
                        
                        df_tmp <- f_top_GO_modules(gene_module = module,
                                                   gene_universe = gene_universe,
                                                   df_gene_go = df_gene_go,
                                                   l_gene_2_GO = l_gene_2_GO,
                                                   go_ontology = "BP") %>%
                                mutate(module = mod_zoom, .before = 1) %>%
                                clean_names() %>%
                                dplyr::select(-term) %>%
                                left_join(df_gene_go %>% dplyr::select(go_id, term),
                                          by = "go_id") %>%
                                dplyr::select(module, go_id, term, everything()) %>%
                                distinct() %>%
                                mutate(mod_set = mod_set_zoom, .before = 1) %>%
                                mutate(module = as.numeric(module))
                        
                        data$df_mods_go <- bind_rows(data$df_mods_go, df_tmp)
                        
                }
                
                for (m in overlap_mods) {
                        
                        # run topGO on overlapping modules
                        if ((nrow(filter(data$df_mods_go, mod_set == mod_set_other, module == m)) == 0)) {
                                
                                doParallel::registerDoParallel()
                                
                                module <- df_modules %>%
                                        filter(mod_set == mod_set_other & module == m) %>%
                                        pull(ensembl_gene_id) %>%
                                        unique()
                                
                                df_tmp <- f_top_GO_modules(gene_module = module,
                                                           gene_universe = gene_universe,
                                                           df_gene_go = df_gene_go,
                                                           l_gene_2_GO = l_gene_2_GO,
                                                           go_ontology = "BP") %>%
                                        mutate(module = m, .before = 1) %>%
                                        clean_names() %>%
                                        dplyr::select(-term) %>%
                                        left_join(df_gene_go %>% dplyr::select(go_id, term),
                                                  by = "go_id") %>%
                                        dplyr::select(module, go_id, term, everything()) %>%
                                        distinct() %>%
                                        mutate(mod_set = mod_set_other, .before = 1) %>%
                                        mutate(module = as.numeric(module))
                                
                                data$df_mods_go <- bind_rows(data$df_mods_go, df_tmp)
                                
                        }
                        
                        # run topGO on gene intersects
                        if ((nrow(filter(data$df_overlaps_go,
                                         mod_set1 == mod_set_zoom, mod1 == mod_zoom,
                                         mod_set2 == mod_set_other, mod2 == m)) == 0)) {
                                
                                # increment progress bar
                                incProgress(1/length(overlap_mods), detail = paste0(mod_set_zoom, " module ", mod_zoom,
                                                                                    " and ", mod_set_other, " module ", m, " intersect"))
                                
                                doParallel::registerDoParallel()
                                
                                module1 <- df_modules %>%
                                        filter(mod_set == mod_set_zoom & module == mod_zoom) %>%
                                        pull(ensembl_gene_id) %>%
                                        unique()
                                
                                module2 <- df_modules %>%
                                        filter(mod_set == mod_set_other & module == m) %>%
                                        pull(ensembl_gene_id) %>%
                                        unique()
                                
                                module_intersect <- intersect(module1, module2)
                                
                                df_tmp <- f_top_GO_modules(gene_module = module_intersect,
                                                           gene_universe = gene_universe,
                                                           df_gene_go = df_gene_go,
                                                           l_gene_2_GO = l_gene_2_GO,
                                                           go_ontology = "BP") %>%
                                        clean_names() %>%
                                        mutate(mod_set1 = mod_set_zoom,
                                               mod_set2 = mod_set_other,
                                               mod1 = mod_zoom,
                                               mod2 = m) %>%
                                        dplyr::select(-term) %>%
                                        left_join(df_gene_go %>% dplyr::select(go_id, term),
                                                  by = "go_id") %>%
                                        # dplyr::select(module, go_id, term, everything()) %>%
                                        distinct() %>%
                                        mutate(mod1 = as.numeric(mod1),
                                               mod2 = as.numeric(mod2))
                                
                                data$df_overlaps_go <- bind_rows(data$df_overlaps_go, df_tmp)
                                
                        }
                        
                }
                
                # remove loading message
                remove_modal_gif()
                
        })
        
        ##
        ## TAB 2 PLOTS
        ##
        
        # number & size of modules
        module_sizes_plot <- reactive({
                
                df_modules <- df_modules_reactive()
                n_mods <- n_mods()
                labels <- 0:n_mods %>% ifelse(. %% 5 == 0, ., "")
                
                df_modules %>%
                        group_by(mod_set) %>%
                        dplyr::count(module) %>%
                        
                        ggplot(aes(x = module, y = n)) +
                        geom_point(aes(color = mod_set, size = n)) +
                        labs(y = "n_genes") +
                        scale_x_discrete(labels = labels,
                                         breaks = seq(from = 0, to = n_mods, by = 1)) +
                        facet_wrap(~mod_set, scales = "free_x") +
                        guides(color = "none") +
                        ggtitle("Number of genes in each module per set")
                
        })
        output$module_sizes <- renderPlot({
                
                module_sizes_plot()
                
        }, height = 650, width = 1000) %>% bindEvent(input$go1)
        output$module_sizes_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_module_sizes_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 10, width = 15)
                        print(module_sizes_plot())
                        dev.off()
                })
        
        
        # main alluvial plot
        main_alluvial_plot <- reactive({
                
                df_modules <- df_modules_reactive()
                df_colors <- df_colors_reactive()
                
                df_alluvial <- df_modules %>%
                        dplyr::select(ensembl_gene_id, mod_set, module) %>%
                        left_join(df_colors, by = "module")
                
                # remove gray module?
                if (input$grey_mod == FALSE) {
                        
                        df_alluvial <- df_alluvial %>% filter(module != 0)
                        
                } else if (input$grey_mod == TRUE) {
                        
                        df_alluvial <- df_alluvial
                        
                }
                
                # plot
                df_alluvial %>%
                        
                        ggplot(aes(x = mod_set, stratum = module, alluvium = ensembl_gene_id)) +
                        stat_stratum() +
                        geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
                        stat_flow(aes(fill = I(color))) +
                        labs(x = "module set") +
                        ggtitle("Alluvial plot")
                
        })
        output$main_alluvial <- renderPlot({
                
                main_alluvial_plot()
                
        }, height = 800, width = 1000) %>% bindEvent(input$go1)
        output$main_alluvial_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_main_alluvial_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 10, width = 15)
                        print(main_alluvial_plot())
                        dev.off()
                })
        
        # overlap matrix plot
        overlap_matrix_plot <- reactive({
                
                df_overlap <- data$df_overlap
                df_modules <- df_modules_reactive()
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                
                modules1 <- df_modules %>%
                        filter(mod_set == modSet1) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique
                
                modules2 <- df_modules %>%
                        filter(mod_set == modSet2) %>%
                        arrange(module) %>%
                        pull(module) %>%
                        unique
                
                # format for plotting
                df_overlap_plot <-
                        df_overlap %>%
                        filter(mod_set1 == modSet1 & mod_set2 == modSet2) %>%
                        mutate(is_big = ifelse(q >= 50, 1 , 0) %>% factor()) %>%
                        mutate(p_adj = ifelse(p_adj > 0.05, NA, p_adj)) %>% # set p_adj = 1 to NA
                        mutate(p_adj = ifelse(p_adj == 0, 1e-300, p_adj)) %>%
                        mutate(mod_set1 = factor(mod_set1, levels = unique(.$mod_set1))) %>%
                        mutate(mod1 = factor(mod1, levels = levels(df_overlap$mod2)),
                               mod2 = factor(mod2, levels = levels(df_overlap$mod2))) %>%
                        dplyr::select(-c(q, m, n, k))
                
                # plot
                df_overlap_plot %>%
                        
                        ggplot(aes(x = mod1, y = mod2)) +
                        geom_tile(aes(fill = -log10(p_adj))) +
                        geom_text(data = df_overlap_plot %>% filter(p_adj < 0.05),
                                  mapping = aes(label = overlap),
                                  size = 6) +
                        
                        scale_fill_gradientn(colors = brewer.pal(5, "Reds"), na.value = "white") +
                        scale_x_discrete(limits = modules1) +
                        scale_y_discrete(limits = modules2) +
                        labs(x = modSet1, y = modSet2) +
                        ggtitle("Hypergeometric overlaps")
                
        })
        output$overlap_matrix <- renderPlot({
                
                overlap_matrix_plot()
                
        }, height = 800, width = 1000) %>% bindEvent(input$go1)
        output$overlap_matrix_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_overlap_matrix_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 10, width = 15)
                        print(overlap_matrix_plot())
                        dev.off()
                })
        output$df_overlap_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_hypergeometrix_overlap.csv")},
                
                content = function(file) {
                        
                        write.csv(data$df_overlap, file, row.names = FALSE)
                        
                }
                
        )
        
        # cell-type enrichment plot
        cell_type_plot <- reactive({
                
                df_modules <- df_modules_reactive()
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                df_cell_type <- df_cell_type_reactive()
                
                df_modules %>%
                        filter(mod_set %in% c(modSet1, modSet2)) %>%
                        
                        dplyr::select(mod_set, ensembl_gene_id, module) %>%
                        left_join(df_cell_type, by = "ensembl_gene_id") %>%
                        group_by(mod_set, module) %>%
                        dplyr::count(type) %>%
                        mutate(z_score = (n - mean(n, na.rm = TRUE))/sd(n, na.rm = TRUE)) %>%
                        na.omit() %>%
                        
                        # filter(!grepl("synapses", type)) %>%
                        
                        ggplot(aes(x = type, y = module,
                                   fill = z_score)) +
                        geom_tile(aes(width = 0.95, height = 0.95)) +
                        scale_fill_gradientn(colors = rev(brewer.pal(9, "RdBu")), limits = c(-3, 3)) +
                        facet_wrap(~mod_set, scales = "free", nrow = 2) +
                        labs(x = "Lake cell type") +
                        coord_flip()
                
        })
        output$cell_type <- renderPlot({
                
                cell_type_plot()
                
        }, height = 800, width = 1000) %>% bindEvent(input$go1)
        output$cell_type_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_cell_type_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 15, width = 15)
                        print(cell_type_plot())
                        dev.off()
                })
        
        
        ##
        ## TAB 3 PLOTS
        ##
        
        # alluvial zoom plot
        zoom_alluvial_plot <- reactive({
                
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom
                
                df_colors <- df_colors_reactive()
                df_modules <- df_modules_reactive()
                df_overlap <- data$df_overlap
                
                # q > 50?
                if (input$q50 == FALSE) {
                        
                        df_overlap <- df_overlap
                        
                } else if (input$q50 == TRUE) {
                        
                        df_overlap <- df_overlap %>% filter(q >= 50)
                        
                }
                
                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)
                
                m <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)
                
                df_alluvial_zoom <- df_modules %>%
                        filter((mod_set == mod_set_zoom & module == mod_zoom) |
                                       (mod_set == mod_set_other & module %in% m))
                
                # plot
                df_alluvial_zoom %>%
                        left_join(df_colors) %>%
                        
                        ggplot(aes(x = mod_set, stratum = module, alluvium = ensembl_gene_id)) +
                        stat_stratum() +
                        geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
                        stat_flow(aes(fill = I(color))) +
                        labs(x = "module set")
                
        })
        output$zoom_alluvial <- renderPlot({
                
                zoom_alluvial_plot()
                
        }, height = 600, width = 1000) %>% bindEvent(input$go2)
        output$zoom_alluvial_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_zoom_alluvial_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 10, width = 15)
                        print(cell_type_plot())
                        dev.off()
                })
        
        # zoomed module enrichment
        zoom_module_go_plot <- reactive({
                
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom
                df_mods_go <- data$df_mods_go
                
                # select module set
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                
                # plot
                df_mods_go %>%
                        filter(mod_set == mod_set_zoom & module == mod_zoom) %>%
                        arrange(p_adj) %>%
                        dplyr::slice(1:10) %>%
                        
                        ggplot(aes(x = -log10(p_adj), y = reorder(str_wrap(term, width = 35), -p_adj))) +
                        geom_point(aes(size = significant/annotated, color = -log10(p_adj))) +
                        labs(y = "") +
                        
                        geom_vline(aes(xintercept = -log10(0.05)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.01)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.001)), lty = 2, color = "black") +
                        scale_color_gradientn(colors = brewer.pal(9, "Reds")[3:9]) +
                        
                        ggtitle(paste0(mod_set_zoom, " module ", mod_zoom, " enrichment"))
                
        })
        output$zoom_module_go <- renderPlot({
                
                zoom_module_go_plot()
                
        }, height = 800, width = 1000) %>% bindEvent(input$go2)
        output$zoom_module_go_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_zoom_module_go_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 20, width = 15)
                        print(zoom_module_go_plot())
                        dev.off()
                })
        
        # zoomed module overlapping modules (full) enrichment
        zoom_module_overlaps_go_plot <- reactive({
                
                # bring in reactives & inputs
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom
                
                # bring in data
                df_overlap <- data$df_overlap
                df_mods_go <- data$df_mods_go
                
                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)
                
                overlap_mods <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)
                
                # plot
                df_mods_go %>%
                        
                        filter(mod_set == mod_set_other & module %in% overlap_mods) %>%
                        group_by(module) %>%
                        arrange(module, p_adj) %>%
                        dplyr::top_n(n = 10) %>%
                        group_modify(~head(.x, 10)) %>%
                        
                        ggplot(aes(x = -log10(p_adj), y = reorder_within(str_wrap(term, width = 35), -p_adj, module))) +
                        geom_point(aes(size = significant/annotated, color = -log10(p_adj))) +
                        labs(y = "") +
                        facet_wrap(~module, scales = "free", ncol = 2) +
                        scale_y_discrete(labels = function(x) gsub("*_.", "", x)) +
                        
                        geom_vline(aes(xintercept = -log10(0.05)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.01)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.001)), lty = 2, color = "black") +
                        scale_color_gradientn(colors = brewer.pal(9, "Reds")[3:9]) +
                        
                        ggtitle(paste0(mod_set_other, " module ", paste(overlap_mods, sep = ", "), " enrichment"))
                
        })
        output$zoom_module_overlaps_go <- renderPlot({
                
                zoom_module_overlaps_go_plot()
                
        }, height = 800, width = 1000) %>% bindEvent(input$go2)
        output$zoom_module_overlaps_go_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_zoom_module_overlaps_go_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 20, width = 15)
                        print(zoom_module_overlaps_go_plot())
                        dev.off()
                })
        output$df_mods_go_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_module_GO_results.csv")},
                
                content = function(file) {
                        
                        write.csv(data$df_mods_go, file, row.names = FALSE)
                        
                }
                
        )
        
        # intersecting gene sets enrichment
        intersects_go_plot <- reactive({
                
                # bring in reactives & inputs
                modSet1 <- mod_set1()
                modSet2 <- mod_set2()
                mod_zoom <- input$mod_zoom
                
                # bring in data
                df_overlap <- data$df_overlap
                df_mods_go <- data$df_mods_go
                df_overlaps_go <- data$df_overlaps_go
                
                # select modules to look at
                mod_set_zoom <- ifelse(input$mod_set_zoom == "Module set 1", modSet1, modSet2)
                mod_set_other <- ifelse(input$mod_set_zoom == "Module set 1", modSet2, modSet1)
                
                overlap_mods <- df_overlap %>%
                        filter(p_adj < 0.05) %>%
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom) %>%
                        filter(mod_set2 == mod_set_other) %>%
                        pull(mod2)
                
                # plot
                df_overlaps_go %>%
                        
                        filter(mod_set1 == mod_set_zoom & mod1 == mod_zoom,
                               mod_set2 == mod_set_other & mod2 %in% overlap_mods) %>%
                        group_by(mod2) %>%
                        arrange(mod2, p_adj) %>%
                        dplyr::top_n(n = 10) %>%
                        group_modify(~head(.x, 10)) %>%
                        
                        ggplot(aes(x = -log10(p_adj), y = reorder_within(str_wrap(term, width = 35), -p_adj, mod2))) +
                        geom_point(aes(size = significant/annotated, color = -log10(p_adj))) +
                        labs(y = "") +
                        facet_wrap(~mod2 , scales = "free", ncol = 2) +
                        scale_y_discrete(labels = function(x) gsub("*_.", "", x)) +
                        
                        geom_vline(aes(xintercept = -log10(0.05)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.01)), lty = 2, color = "black") +
                        geom_vline(aes(xintercept = -log10(0.001)), lty = 2, color = "black") +
                        scale_color_gradientn(colors = brewer.pal(9, "Reds")[3:9]) +
                        
                        ggtitle("Intersecting gene enrichment")
                
        })
        output$intersects_go <- renderPlot({
                
                intersects_go_plot()
                
        }, height = 800, width = 1000) %>% bindEvent(input$go2)
        output$intersects_go_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_", mod_set1(), "_", mod_set2(), "_intersects_go_plot", ".pdf")},
                
                content = function(file) {
                        
                        pdf(file, height = 20, width = 15)
                        print(intersects_go_plot())
                        dev.off()
                })
        output$df_overlaps_go_download <- downloadHandler(
                
                filename = function() {paste0(Sys.Date(), "_module_overlap_GO_results.csv")},
                
                content = function(file) {
                        
                        write.csv(data$df_overlaps_go, file, row.names = FALSE)
                        
                }
                
        )
        
        
}


# Run the application 
shinyApp(ui = ui, server = server)
